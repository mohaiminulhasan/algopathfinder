{"version":3,"sources":["components/Node.jsx","utils/helpers.js","utils/constants.js","utils/PriorityQueue.js","algorithms/dfs.js","algorithms/bfs.js","algorithms/astar.js","components/Grid.jsx","App.js","index.js"],"names":["Node","props","coordinate","row_index","col_index","className","status","onMouseDown","e","handleMouseDown","onMouseEnter","handleMouseEnter","onMouseUp","handleMouseUp","sleep","ms","Promise","resolve","setTimeout","arrayEquals","x","y","output","i","length","isValid","obstacle","j","num_rows","num_cols","findIndex","el","getPath","predecessors","start","end","current","path","push","reverse","updateGrid","grid","setGrid","node","prevGrid","slice","offsets","PriorityQueue","this","items","item","isEmpty","added","splice","shift","toString","dfs","a","directions","neighbours","delay","pop","row_offset","col_offset","neighbour","bfs","heuristic","b","x1","y1","x2","y2","Math","abs","astar","enqueue","g_values","dequeue","new_cost","f_value","Grid","useState","findPath","setFindPath","setStart","setEnd","setObstacle","mousePressed","setMousePressed","fixStart","setFixStart","fixEnd","setFixEnd","algorithm","START_ROW","START_COL","END_ROW","END_COL","useEffect","row","id","initialGrid","toggleObstacle","index","newObstacle","preventDefault","nodes","undefined","forEach","onClick","window","location","reload","disabled","style","gridTemplateColumns","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.98e4d989.chunk.js","sourcesContent":["export const Node = (props) => {\n  const coordinate = [props.row_index, props.col_index]\n\n  return (\n    <div \n      className={`node ${props.status}`}\n      onMouseDown={(e) => props.handleMouseDown(coordinate, e)}\n      onMouseEnter={(e) => props.handleMouseEnter(coordinate, e)}\n      onMouseUp={props.handleMouseUp}\n    ></div>\n  )\n}","import { num_rows, num_cols } from '../utils'\n\nexport const sleep = (ms) => {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nexport const arrayEquals = (x, y) => {\n  let output = true\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] !== y[i]) {\n      output = false\n      break;\n    }\n  }\n  return output\n}\n\nexport const initialGrid = (start, end, obstacle) => {\n  let grid = [], row\n\n  for (let i = 0; i < num_rows; i++) {\n    row = []\n    for (let j = 0; j < num_cols; j++) {\n      row.push({\n        id: `node-${i}-${j}`,\n        status: (start[0] === i && start[1] === j) ? 'start' : (end[0] === i && end[1] === j) ? 'destination' : (obstacle.findIndex(el => arrayEquals([i,j], el)) !== -1) ? 'obstacle' : 'undiscovered'\n      })\n    }\n    grid.push(row)\n  }\n\n  return grid\n}\n\nexport const isValid = (coordinate, obstacle) => {\n  let i, j\n  [i, j] = coordinate\n  return i >= 0 && i < num_rows && j >= 0 && j < num_cols && obstacle.findIndex(el => arrayEquals([i,j], el)) === -1\n}\n\nexport const getPath = (predecessors, start, end) => {\n  let current, path = []\n  current = end\n  while (current !== start) {\n    path.push(current)\n    current = predecessors[current]\n  }\n  path.push(current)\n  path.reverse()\n  return path\n}\n\nexport const updateGrid = (grid, setGrid, current, className) => {\n  let node = grid[current[0]][current[1]]\n  node['status'] = className\n  grid[current[0]][current[1]] = node\n  setGrid(prevGrid => prevGrid.slice())\n}","export const num_rows = 23\nexport const num_cols = 23\n\nexport const offsets = {\n  \"up\": [-1, 0],\n  \"right\": [0, 1],\n  \"down\": [1, 0],\n  \"left\": [0, -1]\n}","export class PriorityQueue {\n  constructor() {\n    this.items = []\n  }\n\n  isEmpty() {\n    return this.items.length === 0;\n  }\n\n  enqueue(item) {\n    if (this.isEmpty()) {\n      this.items.push(item);\n    } else {\n      let added = false;\n      for (let i = 0; i < this.items.length; i++) {\n        if (item[1] < this.items[i][1]) {\n          this.items.splice(i, 0, item);\n          added = true;\n          break;\n        }\n      }\n      if (!added) {\n        this.items.push(item);\n      }\n    }\n  }\n\n  dequeue() {\n    return this.items.shift()[0];\n  }\n\n  peek() {\n    return this.items[0];\n  }\n\n  size() {\n    return this.items.length;\n  }\n\n  toString() {\n    return `[${this.items.toString()}]`;\n  }\n}","import { getPath, isValid, offsets, sleep, updateGrid } from '../utils'\n\nexport const dfs = async (start, end, grid, setGrid, obstacle) => {\n  const directions = [\"up\", \"right\", \"down\", \"left\"]\n  let current, neighbours = [], predecessors, delay = 10;\n\n  neighbours = [start] // <-- this is the stack\n  predecessors = { [start]: null } // <-- this will keep track of the path\n  \n  while (neighbours.length !== 0) { // as long as the neighbours array is not depleted\n    current = neighbours.pop() // get the latest coordinate\n\n    await sleep(delay)\n\n    updateGrid(grid, setGrid, current, 'popped')\n\n    if (current[0] === end[0] && current[1] === end[1]) { // if current coordinate is equal to end coordinate\n      let path = getPath(predecessors, start, end)\n\n      for (let i = 0; i < path.length; i++) {\n        await sleep(delay / 2)\n\n        let current = path[i]\n        updateGrid(grid, setGrid, current, 'path')\n      }\n      return\n    }\n\n    let row_offset, col_offset, neighbour\n    for (let i = 0; i < 4; i++) { // loop through up, right, down, left\n      [row_offset, col_offset] = offsets[directions[i]]\n      neighbour = [current[0] + row_offset, current[1] + col_offset] // get the coordinate of the neighbour\n\n      await sleep(delay / 5) // 1/5th of popped sleep\n\n      if (isValid(neighbour, obstacle) && !(neighbour in predecessors)) { // if neighbour is valid and NOT found in predecessors\n        neighbours.push(neighbour) // add the neighbour to our stack\n        predecessors[neighbour] = current // add the neighbour in predecessors\n        updateGrid(grid, setGrid, neighbour, 'discovered')\n      }\n    }\n  }\n  return\n}","import { getPath, isValid, offsets, sleep, updateGrid } from '../utils'\n\nexport const bfs = async (start, end, grid, setGrid, obstacle) => {\n  const directions = [\"up\", \"right\", \"down\", \"left\"]\n  let current, neighbours = [], predecessors, delay = 10;\n\n  neighbours = [start] // <-- this is the queue\n  predecessors = { [start]: null } // <-- this will keep track of the path\n  \n  while (neighbours.length !== 0) { // as long as the neighbours array is not depleted\n    current = neighbours.shift() // get the oldest coordinate\n\n    await sleep(delay)\n\n    updateGrid(grid, setGrid, current, 'popped')\n\n    if (current[0] === end[0] && current[1] === end[1]) { // if current coordinate is equal to end coordinate\n      let path = getPath(predecessors, start, end)\n\n      for (let i = 0; i < path.length; i++) {\n        await sleep(delay / 2)\n\n        let current = path[i]\n        updateGrid(grid, setGrid, current, 'path')\n      }\n      return\n    }\n\n    let row_offset, col_offset, neighbour\n    for (let i = 0; i < 4; i++) { // loop through up, right, down, left\n      [row_offset, col_offset] = offsets[directions[i]]\n      neighbour = [current[0] + row_offset, current[1] + col_offset] // get the coordinate of the neighbour\n\n      await sleep(delay / 5) // 1/5th of popped sleep\n\n      if (isValid(neighbour, obstacle) && !(neighbour in predecessors)) { // if neighbour is valid and NOT found in predecessors\n        neighbours.push(neighbour) // add the neighbour to our stack\n        predecessors[neighbour] = current // add the neighbour in predecessors\n        updateGrid(grid, setGrid, neighbour, 'discovered')\n      }\n    }\n  }\n  return\n}","import { getPath, isValid, offsets, sleep, updateGrid, PriorityQueue } from '../utils'\n\nconst heuristic = (a, b) => {\n  const [x1, y1] = a;\n  const [x2, y2] = b;\n  return Math.abs(x1 - x2) + Math.abs(y1 - y2);\n}\n\nexport const astar = async (start, end, grid, setGrid, obstacle) => {\n  const directions = [\"up\", \"right\", \"down\", \"left\"]\n  let current, predecessors, delay = 10, g_values;\n\n  let neighbours = new PriorityQueue(); // <-- this is the queue\n  neighbours.enqueue([start, 0])\n  predecessors = { [start]: null } // <-- this will keep track of the path\n  g_values = { [start]: 0 }\n\n  while (!neighbours.isEmpty()) { // as long as the neighbours array is not depleted\n    current = neighbours.dequeue() // get one coordinate\n\n    await sleep(delay)\n\n    updateGrid(grid, setGrid, current, 'popped')\n\n    if (current[0] === end[0] && current[1] === end[1]) { // if current coordinate is equal to end coordinate\n      let path = getPath(predecessors, start, end)\n\n      for (let i = 0; i < path.length; i++) {\n        await sleep(delay / 2)\n\n        let current = path[i]\n        updateGrid(grid, setGrid, current, 'path')\n      }\n      return\n    }\n\n    let row_offset, col_offset, neighbour, new_cost, f_value\n    for (let i = 0; i < 4; i++) { // loop through up, right, down, left\n      [row_offset, col_offset] = offsets[directions[i]]\n      neighbour = [current[0] + row_offset, current[1] + col_offset] // get the coordinate of the neighbour\n\n      await sleep(delay / 5) // 1/5th of popped sleep\n\n      if (isValid(neighbour, obstacle) && !(neighbour in g_values)) { // if neighbour is valid and NOT found in predecessors\n        new_cost = g_values[current] + 1\n        g_values[neighbour] = new_cost\n        f_value = new_cost + heuristic(end, neighbour)\n        neighbours.enqueue([neighbour, f_value]) // add the neighbour to our queue\n        predecessors[neighbour] = current // add the neighbour in predecessors\n        updateGrid(grid, setGrid, neighbour, 'discovered')\n      }\n    }\n  }\n  return\n}","import { useEffect, useState } from 'react'\nimport { Node } from './Node'\nimport { initialGrid, arrayEquals, updateGrid, num_cols } from '../utils'\nimport { dfs, bfs, astar } from '../algorithms'\n\nexport const Grid = () => {\n  const [grid, setGrid] = useState();\n  const [findPath, setFindPath] = useState(false)\n  const [start, setStart] = useState([11, 2])\n  const [end, setEnd] = useState([11, 19])\n  const [obstacle, setObstacle] = useState([])\n  const [mousePressed, setMousePressed] = useState(false)\n  const [fixStart, setFixStart] = useState(false)\n  const [fixEnd, setFixEnd] = useState(false)\n  const [algorithm, setAlgorithm] = useState('astar')\n\n  const START_ROW = start[0]\n  const START_COL = start[1]\n  const END_ROW = end[0]\n  const END_COL = end[1]\n\n  useEffect(() => {\n    setGrid(initialGrid(start, end, obstacle))\n  }, [])\n\n  // useEffect(() => console.log(grid && grid[0]), [grid])\n\n  useEffect(() => {\n    if (findPath) {\n      switch (algorithm) {\n        case 'dfs':\n          dfs([START_ROW, START_COL], [END_ROW, END_COL], grid, setGrid, obstacle, findPath)\n          break\n        case 'bfs':\n          bfs([START_ROW, START_COL], [END_ROW, END_COL], grid, setGrid, obstacle, findPath)\n          break\n        case 'astar':\n          astar([START_ROW, START_COL], [END_ROW, END_COL], grid, setGrid, obstacle, findPath)\n          break\n        default:\n          astar([START_ROW, START_COL], [END_ROW, END_COL], grid, setGrid, obstacle, findPath)\n\n      }\n    }\n  }, [findPath])\n\n  const toggleObstacle = (coordinate) => {\n    if (arrayEquals(start, coordinate) || arrayEquals(end, coordinate)) {\n      return\n    }\n    let index = obstacle.findIndex(el => arrayEquals(coordinate, el))\n    if (index >= 0) {\n      let newObstacle = [...obstacle]\n      newObstacle.splice(index, 1)\n      setObstacle(newObstacle)\n      updateGrid(grid, setGrid, coordinate, 'undiscovered')\n    } else {\n      obstacle.push(coordinate)\n      setObstacle(obstacle)\n      updateGrid(grid, setGrid, coordinate, 'obstacle')\n    }\n  }\n\n  const handleMouseDown = (coordinate, e) => {\n    if (fixStart) {\n      setStart(coordinate)\n      updateGrid(grid, setGrid, start, 'undiscovered')\n      updateGrid(grid, setGrid, coordinate, 'start')\n      setFixStart(false)\n    } else if (fixEnd) {\n      setEnd(coordinate)\n      updateGrid(grid, setGrid, end, 'undiscovered')\n      updateGrid(grid, setGrid, coordinate, 'destination')\n      setFixEnd(false)\n    } else {\n      e.preventDefault()\n      setMousePressed(true)\n      toggleObstacle(coordinate)\n    }\n  }\n\n  const handleMouseEnter = (coordinate) => {\n    if (mousePressed) {\n      toggleObstacle(coordinate)\n    }\n  }\n\n  const handleMouseUp = () => {\n    setMousePressed(false)\n  }\n\n  const handleFixStart = () => {\n    setFixStart(true)\n  }\n\n  const handleFixEnd = () => {\n    setFixEnd(true)\n  }\n\n  let nodes = []\n  if (grid !== undefined) {\n    grid.forEach((row, row_index) => {\n      row.forEach((node, col_index) => {\n        nodes.push(<Node \n                      key={node.id} \n                      id={node.id} \n                      status={node.status} \n                      row_index={row_index}\n                      col_index={col_index}\n                      toggleObstacle={toggleObstacle}\n                      handleMouseDown={handleMouseDown}\n                      handleMouseEnter={handleMouseEnter}\n                      handleMouseUp={handleMouseUp}\n                      />)\n      });\n    });\n  }\n\n  return (\n    <div className='wrapper'>\n      <div className='controls'>\n        <div>\n          <button onClick={() => setFindPath(true)}>Find Path</button>\n          <button onClick={() => window.location.reload()}>Stop/Reset</button>\n        </div>\n        <div>\n          <button onClick={handleFixStart} disabled={fixStart}>Fix Start</button>\n          <button onClick={handleFixEnd} disabled={fixEnd}>Fix End</button>\n        </div>\n      </div>\n\n      <div className='container' style={{ gridTemplateColumns: `repeat(${num_cols}, 1fr)`}}>\n        {nodes}\n      </div>\n    </div>\n  )\n}","import './App.css';\nimport { Grid } from './components'\n\nfunction App() {\n  return (\n    <div className='main'>\n      <Grid/>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}