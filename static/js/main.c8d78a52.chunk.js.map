{"version":3,"sources":["components/Node.jsx","utils/helpers.js","utils/constants.js","algorithms/dfs.js","components/Grid.jsx","App.js","index.js"],"names":["Node","props","coordinate","row_index","col_index","className","status","onMouseDown","e","handleMouseDown","onMouseEnter","handleMouseEnter","onMouseUp","handleMouseUp","sleep","ms","Promise","resolve","setTimeout","arrayEquals","x","y","output","i","length","isValid","obstacle","j","num_rows","num_cols","findIndex","el","getPath","predecessors","start","end","current","path","push","reverse","updateGrid","grid","setGrid","node","prevGrid","slice","offsets","dfs","a","directions","neighbours","delay","pop","row_offset","col_offset","neighbour","Grid","useState","findPath","setFindPath","setStart","setEnd","setObstacle","mousePressed","setMousePressed","fixStart","setFixStart","fixEnd","setFixEnd","START_ROW","START_COL","END_ROW","END_COL","useEffect","row","id","initialGrid","console","log","toggleObstacle","index","newObstacle","splice","preventDefault","nodes","undefined","forEach","onClick","window","location","reload","disabled","style","gridTemplateColumns","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"2NAAaA,EAAO,SAACC,GACnB,IAAMC,EAAa,CAACD,EAAME,UAAWF,EAAMG,WAE3C,OACE,qBACEC,UAAS,eAAUJ,EAAMK,QACzBC,YAAa,SAACC,GAAD,OAAOP,EAAMQ,gBAAgBP,EAAYM,IACtDE,aAAc,SAACF,GAAD,OAAOP,EAAMU,iBAAiBT,EAAYM,IACxDI,UAAWX,EAAMY,iB,eCNVC,EAAQ,SAACC,GACpB,OAAO,IAAIC,SAAQ,SAAAC,GAAO,OAAIC,WAAWD,EAASF,OAGvCI,EAAc,SAACC,EAAGC,GAE7B,IADA,IAAIC,GAAS,EACJC,EAAI,EAAGA,EAAIH,EAAEI,OAAQD,IAC5B,GAAIH,EAAEG,KAAOF,EAAEE,GAAI,CACjBD,GAAS,EACT,MAGJ,OAAOA,GAoBIG,EAAU,SAACvB,EAAYwB,GAClC,IAAIH,EAAGI,EADwC,cAEtCzB,EAFsC,GAG/C,OADCqB,EAF8C,KAE3CI,EAF2C,KAGxCJ,GAAK,GAAKA,EAAIK,GAAYD,GAAK,GAAKA,EAAIE,IAAkE,IAAtDH,EAASI,WAAU,SAAAC,GAAE,OAAIZ,EAAY,CAACI,EAAEI,GAAII,OAG5FC,EAAU,SAACC,EAAcC,EAAOC,GAC3C,IAAIC,EAASC,EAAO,GAEpB,IADAD,EAAUD,EACHC,IAAYF,GACjBG,EAAKC,KAAKF,GACVA,EAAUH,EAAaG,GAIzB,OAFAC,EAAKC,KAAKF,GACVC,EAAKE,UACEF,GAGIG,EAAa,SAACC,EAAMC,EAASN,EAAS/B,GACjD,IAAIsC,EAAOF,EAAKL,EAAQ,IAAIA,EAAQ,IACpCO,EAAI,OAAatC,EACjBoC,EAAKL,EAAQ,IAAIA,EAAQ,IAAMO,EAC/BD,GAAQ,SAAAE,GAAQ,OAAIA,EAASC,YCxDlBjB,EAAW,GACXC,EAAW,GAEXiB,EAAU,CACrB,GAAM,EAAE,EAAG,GACX,MAAS,CAAC,EAAG,GACb,KAAQ,CAAC,EAAG,GACZ,KAAQ,CAAC,GAAI,I,8BCLFC,EAAG,uCAAG,WAAOb,EAAOC,EAAKM,EAAMC,EAAShB,GAAlC,uCAAAsB,EAAA,sDACXC,EAAa,CAAC,KAAM,QAAS,OAAQ,QAC9BC,EAAa,GAAkBC,EAAQ,GAEpDD,EAAa,CAAChB,GACdD,EAAY,eAAMC,EAAQ,MALT,UAOY,IAAtBgB,EAAW1B,OAPD,wBAQfY,EAAUc,EAAWE,MARN,SAUTtC,EAAMqC,GAVG,UAYfX,EAAWC,EAAMC,EAASN,EAAS,UAE/BA,EAAQ,KAAOD,EAAI,IAAMC,EAAQ,KAAOD,EAAI,GAdjC,iBAeTE,EAAOL,EAAQC,EAAcC,EAAOC,GAE/BZ,EAAI,EAjBA,aAiBGA,EAAIc,EAAKb,QAjBZ,kCAkBLV,EAAMqC,EAAQ,GAlBT,QAoBPf,EAAUC,EAAKd,GACnBiB,EAAWC,EAAMC,EAASN,EAAS,QArBxB,QAiBoBb,IAjBpB,0DA0BX8B,OA1BW,EA0BCC,OA1BD,EA0BaC,OA1Bb,EA2BNhC,EAAI,EA3BE,aA2BCA,EAAI,GA3BL,sCA4BcuB,EAAQG,EAAW1B,IA5BjC,GA4BZ8B,EA5BY,KA4BAC,EA5BA,KA6BbC,EAAY,CAACnB,EAAQ,GAAKiB,EAAYjB,EAAQ,GAAKkB,GA7BtC,UA+BPxC,EAAMqC,EAAQ,GA/BP,QAiCT1B,EAAQ8B,EAAW7B,MAAe6B,KAAatB,KACjDiB,EAAWZ,KAAKiB,GAChBtB,EAAasB,GAAanB,EAC1BI,EAAWC,EAAMC,EAASa,EAAW,eApC1B,QA2BQhC,IA3BR,qHAAH,8DCGHiC,EAAO,WAAO,IAAD,EACAC,qBADA,mBACjBhB,EADiB,KACXC,EADW,OAEQe,oBAAS,GAFjB,mBAEjBC,EAFiB,KAEPC,EAFO,OAGEF,mBAAS,CAAC,EAAG,IAHf,mBAGjBvB,EAHiB,KAGV0B,EAHU,OAIFH,mBAAS,CAAC,EAAG,IAJX,mBAIjBtB,EAJiB,KAIZ0B,EAJY,OAKQJ,mBAAS,IALjB,mBAKjB/B,EALiB,KAKPoC,EALO,OAMgBL,oBAAS,GANzB,mBAMjBM,EANiB,KAMHC,EANG,OAOQP,oBAAS,GAPjB,mBAOjBQ,EAPiB,KAOPC,EAPO,OAQIT,oBAAS,GARb,mBAQjBU,EARiB,KAQTC,EARS,KAUlBC,EAAYnC,EAAM,GAClBoC,EAAYpC,EAAM,GAClBqC,EAAUpC,EAAI,GACdqC,EAAUrC,EAAI,GAEpBsC,qBAAU,WACR/B,EHJuB,SAACR,EAAOC,EAAKT,GAGtC,IAFA,IAAegD,EAAXjC,EAAO,GADwC,WAG1ClB,GACPmD,EAAM,GACN,IALiD,eAKxC/C,GACP+C,EAAIpC,KAAK,CACPqC,GAAG,QAAD,OAAUpD,EAAV,YAAeI,GACjBrB,OAAS4B,EAAM,KAAOX,GAAKW,EAAM,KAAOP,EAAK,QAAWQ,EAAI,KAAOZ,GAAKY,EAAI,KAAOR,EAAK,eAAuE,IAAtDD,EAASI,WAAU,SAAAC,GAAE,OAAIZ,EAAY,CAACI,EAAEI,GAAII,MAAe,WAAa,kBAH5KJ,EAAI,EAAGA,EAAIE,EAAUF,IAAM,EAA3BA,GAMTc,EAAKH,KAAKoC,IARHnD,EAAI,EAAGA,EAAIK,EAAUL,IAAM,EAA3BA,GAWT,OAAOkB,EGVGmC,CAAY1C,EAAOC,EAAKT,MAC/B,IAEH+C,qBAAU,kBAAMI,QAAQC,IAAIrC,GAAQA,EAAK,MAAK,CAACA,IAE/CgC,qBAAU,WACJf,GACFX,EAAI,CAACsB,EAAWC,GAAY,CAACC,EAASC,GAAU/B,EAAMC,EAAShB,EAAUgC,KAE1E,CAACA,IAEJ,IAAMqB,EAAiB,SAAC7E,GACtB,IAAIiB,EAAYe,EAAOhC,KAAeiB,EAAYgB,EAAKjC,GAAvD,CAGA,IAAI8E,EAAQtD,EAASI,WAAU,SAAAC,GAAE,OAAIZ,EAAYjB,EAAY6B,MAC7D,GAAIiD,GAAS,EAAG,CACd,IAAIC,EAAW,YAAOvD,GACtBuD,EAAYC,OAAOF,EAAO,GAC1BlB,EAAYmB,GACZzC,EAAWC,EAAMC,EAASxC,EAAY,qBAEtCwB,EAASY,KAAKpC,GACd4D,EAAYpC,GACZc,EAAWC,EAAMC,EAASxC,EAAY,cAIpCO,EAAkB,SAACP,EAAYM,GAC/ByD,GACFL,EAAS1D,GACTsC,EAAWC,EAAMC,EAASR,EAAO,gBACjCM,EAAWC,EAAMC,EAASxC,EAAY,SACtCgE,GAAY,IACHC,GACTN,EAAO3D,GACPsC,EAAWC,EAAMC,EAASP,EAAK,gBAC/BK,EAAWC,EAAMC,EAASxC,EAAY,eACtCkE,GAAU,KAEV5D,EAAE2E,iBACFnB,GAAgB,GAChBe,EAAe7E,KAIbS,EAAmB,SAACT,GACpB6D,GACFgB,EAAe7E,IAIbW,EAAgB,WACpBmD,GAAgB,IAWdoB,EAAQ,GAmBZ,YAlBaC,IAAT5C,GACFA,EAAK6C,SAAQ,SAACZ,EAAKvE,GACjBuE,EAAIY,SAAQ,SAAC3C,EAAMvC,GACjBgF,EAAM9C,KAAK,cAAC,EAAD,CAEGqC,GAAIhC,EAAKgC,GACTrE,OAAQqC,EAAKrC,OACbH,UAAWA,EACXC,UAAWA,EACX2E,eAAgBA,EAChBtE,gBAAiBA,EACjBE,iBAAkBA,EAClBE,cAAeA,GARV8B,EAAKgC,WAe5B,qCACA,wBAAQY,QAAS,kBAAM5B,GAAY,IAAnC,uBACA,wBAAQ4B,QAAS,kBAAMC,OAAOC,SAASC,UAAvC,wBACA,wBAAQH,QA/Ba,WACrBrB,GAAY,IA8BqByB,SAAU1B,EAA3C,uBACA,wBAAQsB,QA5BW,WACnBnB,GAAU,IA2BqBuB,SAAUxB,EAAzC,qBAEA,qBAAK9D,UAAU,YAAYuF,MAAO,CAAEC,oBAAoB,UAAD,OAAYhE,EAAZ,WAAvD,SACGuD,QCrGQU,MARf,WACE,OACE,qBAAKzF,UAAU,OAAf,SACE,cAAC,EAAD,OCDN0F,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,W","file":"static/js/main.c8d78a52.chunk.js","sourcesContent":["export const Node = (props) => {\n  const coordinate = [props.row_index, props.col_index]\n\n  return (\n    <div \n      className={`node ${props.status}`}\n      onMouseDown={(e) => props.handleMouseDown(coordinate, e)}\n      onMouseEnter={(e) => props.handleMouseEnter(coordinate, e)}\n      onMouseUp={props.handleMouseUp}\n    ></div>\n  )\n}","import { num_rows, num_cols } from '../utils'\n\nexport const sleep = (ms) => {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nexport const arrayEquals = (x, y) => {\n  let output = true\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] !== y[i]) {\n      output = false\n      break;\n    }\n  }\n  return output\n}\n\nexport const initialGrid = (start, end, obstacle) => {\n  let grid = [], row\n\n  for (let i = 0; i < num_rows; i++) {\n    row = []\n    for (let j = 0; j < num_cols; j++) {\n      row.push({\n        id: `node-${i}-${j}`,\n        status: (start[0] === i && start[1] === j) ? 'start' : (end[0] === i && end[1] === j) ? 'destination' : (obstacle.findIndex(el => arrayEquals([i,j], el)) !== -1) ? 'obstacle' : 'undiscovered'\n      })\n    }\n    grid.push(row)\n  }\n\n  return grid\n}\n\nexport const isValid = (coordinate, obstacle) => {\n  let i, j\n  [i, j] = coordinate\n  return i >= 0 && i < num_rows && j >= 0 && j < num_cols && obstacle.findIndex(el => arrayEquals([i,j], el)) === -1\n}\n\nexport const getPath = (predecessors, start, end) => {\n  let current, path = []\n  current = end\n  while (current !== start) {\n    path.push(current)\n    current = predecessors[current]\n  }\n  path.push(current)\n  path.reverse()\n  return path\n}\n\nexport const updateGrid = (grid, setGrid, current, className) => {\n  let node = grid[current[0]][current[1]]\n  node['status'] = className\n  grid[current[0]][current[1]] = node\n  setGrid(prevGrid => prevGrid.slice())\n}","export const num_rows = 15\nexport const num_cols = 15\n\nexport const offsets = {\n  \"up\": [-1, 0],\n  \"right\": [0, 1],\n  \"down\": [1, 0],\n  \"left\": [0, -1]\n}","import { getPath, isValid, offsets, sleep, updateGrid } from '../utils'\n\nexport const dfs = async (start, end, grid, setGrid, obstacle) => {\n  const directions = [\"up\", \"right\", \"down\", \"left\"]\n  let current, neighbours = [], predecessors, delay = 10;\n\n  neighbours = [start] // <-- this is the stack\n  predecessors = { [start]: null } // <-- this will keep track of the path\n  \n  while (neighbours.length !== 0) { // as long as the neighbours array is not depleted\n    current = neighbours.pop() // get the latest coordinate\n\n    await sleep(delay)\n\n    updateGrid(grid, setGrid, current, 'popped')\n\n    if (current[0] === end[0] && current[1] === end[1]) { // if current coordinate is equal to end coordinate\n      let path = getPath(predecessors, start, end)\n\n      for (let i = 0; i < path.length; i++) {\n        await sleep(delay / 2)\n\n        let current = path[i]\n        updateGrid(grid, setGrid, current, 'path')\n      }\n      return\n    }\n\n    let row_offset, col_offset, neighbour\n    for (let i = 0; i < 4; i++) { // loop through up, right, down, left\n      [row_offset, col_offset] = offsets[directions[i]]\n      neighbour = [current[0] + row_offset, current[1] + col_offset] // get the coordinate of the neighbour\n\n      await sleep(delay / 5) // 1/5th of popped sleep\n\n      if (isValid(neighbour, obstacle) && !(neighbour in predecessors)) { // if neighbour is valid and NOT found in predecessors\n        neighbours.push(neighbour) // add the neighbour to our stack\n        predecessors[neighbour] = current // add the neighbour in predecessors\n        updateGrid(grid, setGrid, neighbour, 'discovered')\n      }\n    }\n  }\n  return\n}","import { useEffect, useState } from 'react'\nimport { Node } from './Node'\nimport { initialGrid, arrayEquals, updateGrid, num_cols } from '../utils'\nimport { dfs } from '../algorithms'\n\nexport const Grid = () => {\n  const [grid, setGrid] = useState();\n  const [findPath, setFindPath] = useState(false)\n  const [start, setStart] = useState([0, 0])\n  const [end, setEnd] = useState([9, 4])\n  const [obstacle, setObstacle] = useState([])\n  const [mousePressed, setMousePressed] = useState(false)\n  const [fixStart, setFixStart] = useState(false)\n  const [fixEnd, setFixEnd] = useState(false)\n\n  const START_ROW = start[0]\n  const START_COL = start[1]\n  const END_ROW = end[0]\n  const END_COL = end[1]\n\n  useEffect(() => {\n    setGrid(initialGrid(start, end, obstacle))\n  }, [])\n\n  useEffect(() => console.log(grid && grid[0]), [grid])\n\n  useEffect(() => {\n    if (findPath) {\n      dfs([START_ROW, START_COL], [END_ROW, END_COL], grid, setGrid, obstacle, findPath)\n    }\n  }, [findPath])\n\n  const toggleObstacle = (coordinate) => {\n    if (arrayEquals(start, coordinate) || arrayEquals(end, coordinate)) {\n      return\n    }\n    let index = obstacle.findIndex(el => arrayEquals(coordinate, el))\n    if (index >= 0) {\n      let newObstacle = [...obstacle]\n      newObstacle.splice(index, 1)\n      setObstacle(newObstacle)\n      updateGrid(grid, setGrid, coordinate, 'undiscovered')\n    } else {\n      obstacle.push(coordinate)\n      setObstacle(obstacle)\n      updateGrid(grid, setGrid, coordinate, 'obstacle')\n    }\n  }\n\n  const handleMouseDown = (coordinate, e) => {\n    if (fixStart) {\n      setStart(coordinate)\n      updateGrid(grid, setGrid, start, 'undiscovered')\n      updateGrid(grid, setGrid, coordinate, 'start')\n      setFixStart(false)\n    } else if (fixEnd) {\n      setEnd(coordinate)\n      updateGrid(grid, setGrid, end, 'undiscovered')\n      updateGrid(grid, setGrid, coordinate, 'destination')\n      setFixEnd(false)\n    } else {\n      e.preventDefault()\n      setMousePressed(true)\n      toggleObstacle(coordinate)\n    }\n  }\n\n  const handleMouseEnter = (coordinate) => {\n    if (mousePressed) {\n      toggleObstacle(coordinate)\n    }\n  }\n\n  const handleMouseUp = () => {\n    setMousePressed(false)\n  }\n\n  const handleFixStart = () => {\n    setFixStart(true)\n  }\n\n  const handleFixEnd = () => {\n    setFixEnd(true)\n  }\n\n  let nodes = []\n  if (grid !== undefined) {\n    grid.forEach((row, row_index) => {\n      row.forEach((node, col_index) => {\n        nodes.push(<Node \n                      key={node.id} \n                      id={node.id} \n                      status={node.status} \n                      row_index={row_index}\n                      col_index={col_index}\n                      toggleObstacle={toggleObstacle}\n                      handleMouseDown={handleMouseDown}\n                      handleMouseEnter={handleMouseEnter}\n                      handleMouseUp={handleMouseUp}\n                      />)\n      });\n    });\n  }\n\n  return (\n    <>\n    <button onClick={() => setFindPath(true)}>Find Path</button>\n    <button onClick={() => window.location.reload()}>Stop/Reset</button>\n    <button onClick={handleFixStart} disabled={fixStart}>Fix Start</button>\n    <button onClick={handleFixEnd} disabled={fixEnd}>Fix End</button>\n\n    <div className='container' style={{ gridTemplateColumns: `repeat(${num_cols}, 1fr)`}}>\n      {nodes}\n    </div>\n    </>\n  )\n}","import './App.css';\nimport { Grid } from './components'\n\nfunction App() {\n  return (\n    <div className='main'>\n      <Grid/>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}