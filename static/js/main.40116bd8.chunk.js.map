{"version":3,"sources":["components/Node.jsx","utils/helpers.js","utils/constants.js","utils/PriorityQueue.js","algorithms/dfs.js","algorithms/bfs.js","algorithms/astar.js","components/Grid.jsx","App.js","index.js"],"names":["Node","props","coordinate","row_index","col_index","className","status","onMouseDown","e","handleMouseDown","onMouseEnter","handleMouseEnter","onMouseUp","handleMouseUp","sleep","ms","Promise","resolve","setTimeout","arrayEquals","x","y","output","i","length","initialGrid","start","end","obstacle","row","grid","j","push","id","findIndex","el","num_cols","num_rows","isValid","getPath","predecessors","current","path","reverse","updateGrid","setGrid","node","prevGrid","slice","offsets","PriorityQueue","this","items","item","isEmpty","added","splice","shift","toString","dfs","a","directions","neighbours","delay","pop","row_offset","col_offset","neighbour","bfs","heuristic","b","x1","y1","x2","y2","Math","abs","astar","enqueue","g_values","dequeue","new_cost","f_value","Grid","useState","findPath","setFindPath","setStart","setEnd","setObstacle","mousePressed","setMousePressed","fixStart","setFixStart","fixEnd","setFixEnd","algorithm","setAlgorithm","START_ROW","START_COL","END_ROW","END_COL","useEffect","toggleObstacle","index","newObstacle","preventDefault","nodes","undefined","forEach","type","name","value","checked","onChange","target","htmlFor","onClick","window","location","reload","disabled","style","gridTemplateColumns","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.40116bd8.chunk.js","sourcesContent":["export const Node = (props) => {\n  const coordinate = [props.row_index, props.col_index]\n\n  return (\n    <div \n      className={`node ${props.status}`}\n      onMouseDown={(e) => props.handleMouseDown(coordinate, e)}\n      onMouseEnter={(e) => props.handleMouseEnter(coordinate, e)}\n      onMouseUp={props.handleMouseUp}\n    ></div>\n  )\n}","import { num_rows, num_cols } from '../utils'\n\nexport const sleep = (ms) => {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nexport const arrayEquals = (x, y) => {\n  let output = true\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] !== y[i]) {\n      output = false\n      break;\n    }\n  }\n  return output\n}\n\nexport const initialGrid = (start, end, obstacle) => {\n  let grid = [], row\n\n  for (let i = 0; i < num_rows; i++) {\n    row = []\n    for (let j = 0; j < num_cols; j++) {\n      row.push({\n        id: `node-${i}-${j}`,\n        status: (start[0] === i && start[1] === j) ? 'start' : (end[0] === i && end[1] === j) ? 'destination' : (obstacle.findIndex(el => arrayEquals([i,j], el)) !== -1) ? 'obstacle' : 'undiscovered'\n      })\n    }\n    grid.push(row)\n  }\n\n  return grid\n}\n\nexport const isValid = (coordinate, obstacle) => {\n  let i, j\n  [i, j] = coordinate\n  return i >= 0 && i < num_rows && j >= 0 && j < num_cols && obstacle.findIndex(el => arrayEquals([i,j], el)) === -1\n}\n\nexport const getPath = (predecessors, start, end) => {\n  let current, path = []\n  current = end\n  while (current !== start) {\n    path.push(current)\n    current = predecessors[current]\n  }\n  path.push(current)\n  path.reverse()\n  return path\n}\n\nexport const updateGrid = (grid, setGrid, current, className) => {\n  let node = grid[current[0]][current[1]]\n  node['status'] = className\n  grid[current[0]][current[1]] = node\n  setGrid(prevGrid => prevGrid.slice())\n}","export const num_rows = 23\nexport const num_cols = 23\n\nexport const offsets = {\n  \"up\": [-1, 0],\n  \"right\": [0, 1],\n  \"down\": [1, 0],\n  \"left\": [0, -1]\n}","export class PriorityQueue {\n  constructor() {\n    this.items = []\n  }\n\n  isEmpty() {\n    return this.items.length === 0;\n  }\n\n  enqueue(item) {\n    if (this.isEmpty()) {\n      this.items.push(item);\n    } else {\n      let added = false;\n      for (let i = 0; i < this.items.length; i++) {\n        if (item[1] < this.items[i][1]) {\n          this.items.splice(i, 0, item);\n          added = true;\n          break;\n        }\n      }\n      if (!added) {\n        this.items.push(item);\n      }\n    }\n  }\n\n  dequeue() {\n    return this.items.shift()[0];\n  }\n\n  peek() {\n    return this.items[0];\n  }\n\n  size() {\n    return this.items.length;\n  }\n\n  toString() {\n    return `[${this.items.toString()}]`;\n  }\n}","import { getPath, isValid, offsets, sleep, updateGrid } from '../utils'\n\nexport const dfs = async (start, end, grid, setGrid, obstacle) => {\n  const directions = [\"up\", \"right\", \"down\", \"left\"]\n  let current, neighbours = [], predecessors, delay = 10;\n\n  neighbours = [start] // <-- this is the stack\n  predecessors = { [start]: null } // <-- this will keep track of the path\n  \n  while (neighbours.length !== 0) { // as long as the neighbours array is not depleted\n    current = neighbours.pop() // get the latest coordinate\n\n    await sleep(delay)\n\n    updateGrid(grid, setGrid, current, 'popped')\n\n    if (current[0] === end[0] && current[1] === end[1]) { // if current coordinate is equal to end coordinate\n      let path = getPath(predecessors, start, end)\n\n      for (let i = 0; i < path.length; i++) {\n        await sleep(delay / 2)\n\n        let current = path[i]\n        updateGrid(grid, setGrid, current, 'path')\n      }\n      return\n    }\n\n    let row_offset, col_offset, neighbour\n    for (let i = 0; i < 4; i++) { // loop through up, right, down, left\n      [row_offset, col_offset] = offsets[directions[i]]\n      neighbour = [current[0] + row_offset, current[1] + col_offset] // get the coordinate of the neighbour\n\n      await sleep(delay / 5) // 1/5th of popped sleep\n\n      if (isValid(neighbour, obstacle) && !(neighbour in predecessors)) { // if neighbour is valid and NOT found in predecessors\n        neighbours.push(neighbour) // add the neighbour to our stack\n        predecessors[neighbour] = current // add the neighbour in predecessors\n        updateGrid(grid, setGrid, neighbour, 'discovered')\n      }\n    }\n  }\n  return\n}","import { getPath, isValid, offsets, sleep, updateGrid } from '../utils'\n\nexport const bfs = async (start, end, grid, setGrid, obstacle) => {\n  const directions = [\"up\", \"right\", \"down\", \"left\"]\n  let current, neighbours = [], predecessors, delay = 10;\n\n  neighbours = [start] // <-- this is the queue\n  predecessors = { [start]: null } // <-- this will keep track of the path\n  \n  while (neighbours.length !== 0) { // as long as the neighbours array is not depleted\n    current = neighbours.shift() // get the oldest coordinate\n\n    await sleep(delay)\n\n    updateGrid(grid, setGrid, current, 'popped')\n\n    if (current[0] === end[0] && current[1] === end[1]) { // if current coordinate is equal to end coordinate\n      let path = getPath(predecessors, start, end)\n\n      for (let i = 0; i < path.length; i++) {\n        await sleep(delay / 2)\n\n        let current = path[i]\n        updateGrid(grid, setGrid, current, 'path')\n      }\n      return\n    }\n\n    let row_offset, col_offset, neighbour\n    for (let i = 0; i < 4; i++) { // loop through up, right, down, left\n      [row_offset, col_offset] = offsets[directions[i]]\n      neighbour = [current[0] + row_offset, current[1] + col_offset] // get the coordinate of the neighbour\n\n      await sleep(delay / 5) // 1/5th of popped sleep\n\n      if (isValid(neighbour, obstacle) && !(neighbour in predecessors)) { // if neighbour is valid and NOT found in predecessors\n        neighbours.push(neighbour) // add the neighbour to our stack\n        predecessors[neighbour] = current // add the neighbour in predecessors\n        updateGrid(grid, setGrid, neighbour, 'discovered')\n      }\n    }\n  }\n  return\n}","import { getPath, isValid, offsets, sleep, updateGrid, PriorityQueue } from '../utils'\n\nconst heuristic = (a, b) => {\n  const [x1, y1] = a;\n  const [x2, y2] = b;\n  return Math.abs(x1 - x2) + Math.abs(y1 - y2);\n}\n\nexport const astar = async (start, end, grid, setGrid, obstacle) => {\n  const directions = [\"up\", \"right\", \"down\", \"left\"]\n  let current, predecessors, delay = 10, g_values;\n\n  let neighbours = new PriorityQueue(); // <-- this is the queue\n  neighbours.enqueue([start, 0])\n  predecessors = { [start]: null } // <-- this will keep track of the path\n  g_values = { [start]: 0 }\n\n  while (!neighbours.isEmpty()) { // as long as the neighbours array is not depleted\n    current = neighbours.dequeue() // get one coordinate\n\n    await sleep(delay)\n\n    updateGrid(grid, setGrid, current, 'popped')\n\n    if (current[0] === end[0] && current[1] === end[1]) { // if current coordinate is equal to end coordinate\n      let path = getPath(predecessors, start, end)\n\n      for (let i = 0; i < path.length; i++) {\n        await sleep(delay / 2)\n\n        let current = path[i]\n        updateGrid(grid, setGrid, current, 'path')\n      }\n      return\n    }\n\n    let row_offset, col_offset, neighbour, new_cost, f_value\n    for (let i = 0; i < 4; i++) { // loop through up, right, down, left\n      [row_offset, col_offset] = offsets[directions[i]]\n      neighbour = [current[0] + row_offset, current[1] + col_offset] // get the coordinate of the neighbour\n\n      await sleep(delay / 5) // 1/5th of popped sleep\n\n      if (isValid(neighbour, obstacle) && !(neighbour in g_values)) { // if neighbour is valid and NOT found in predecessors\n        new_cost = g_values[current] + 1\n        g_values[neighbour] = new_cost\n        f_value = new_cost + heuristic(end, neighbour)\n        neighbours.enqueue([neighbour, f_value]) // add the neighbour to our queue\n        predecessors[neighbour] = current // add the neighbour in predecessors\n        updateGrid(grid, setGrid, neighbour, 'discovered')\n      }\n    }\n  }\n  return\n}","import { useEffect, useState } from 'react'\nimport { Node } from './Node'\nimport { initialGrid, arrayEquals, updateGrid, num_cols } from '../utils'\nimport { dfs, bfs, astar } from '../algorithms'\n\nexport const Grid = () => {\n  const [grid, setGrid] = useState();\n  const [findPath, setFindPath] = useState(false)\n  const [start, setStart] = useState([11, 2])\n  const [end, setEnd] = useState([11, 19])\n  const [obstacle, setObstacle] = useState([])\n  const [mousePressed, setMousePressed] = useState(false)\n  const [fixStart, setFixStart] = useState(false)\n  const [fixEnd, setFixEnd] = useState(false)\n  const [algorithm, setAlgorithm] = useState('dfs')\n\n  const START_ROW = start[0]\n  const START_COL = start[1]\n  const END_ROW = end[0]\n  const END_COL = end[1]\n\n  useEffect(() => {\n    setGrid(initialGrid(start, end, obstacle))\n  }, [])\n\n  useEffect(() => {\n    if (findPath) {\n      switch (algorithm) {\n        case 'dfs':\n          dfs([START_ROW, START_COL], [END_ROW, END_COL], grid, setGrid, obstacle, findPath)\n          break\n        case 'bfs':\n          bfs([START_ROW, START_COL], [END_ROW, END_COL], grid, setGrid, obstacle, findPath)\n          break\n        case 'astar':\n          astar([START_ROW, START_COL], [END_ROW, END_COL], grid, setGrid, obstacle, findPath)\n          break\n        default:\n          astar([START_ROW, START_COL], [END_ROW, END_COL], grid, setGrid, obstacle, findPath)\n\n      }\n      setFindPath(false)\n    }\n  }, [findPath])\n\n  const toggleObstacle = (coordinate) => {\n    if (arrayEquals(start, coordinate) || arrayEquals(end, coordinate)) {\n      return\n    }\n    let index = obstacle.findIndex(el => arrayEquals(coordinate, el))\n    if (index >= 0) {\n      let newObstacle = [...obstacle]\n      newObstacle.splice(index, 1)\n      setObstacle(newObstacle)\n      updateGrid(grid, setGrid, coordinate, 'undiscovered')\n    } else {\n      obstacle.push(coordinate)\n      setObstacle(obstacle)\n      updateGrid(grid, setGrid, coordinate, 'obstacle')\n    }\n  }\n\n  const handleMouseDown = (coordinate, e) => {\n    if (fixStart) {\n      setStart(coordinate)\n      updateGrid(grid, setGrid, start, 'undiscovered')\n      updateGrid(grid, setGrid, coordinate, 'start')\n      setFixStart(false)\n    } else if (fixEnd) {\n      setEnd(coordinate)\n      updateGrid(grid, setGrid, end, 'undiscovered')\n      updateGrid(grid, setGrid, coordinate, 'destination')\n      setFixEnd(false)\n    } else {\n      e.preventDefault()\n      setMousePressed(true)\n      toggleObstacle(coordinate)\n    }\n  }\n\n  const handleMouseEnter = (coordinate) => {\n    if (mousePressed) {\n      toggleObstacle(coordinate)\n    }\n  }\n\n  const handleMouseUp = () => {\n    setMousePressed(false)\n  }\n\n  const handleFixStart = () => {\n    setFixStart(true)\n  }\n\n  const handleFixEnd = () => {\n    setFixEnd(true)\n  }\n\n  let nodes = []\n  if (grid !== undefined) {\n    grid.forEach((row, row_index) => {\n      row.forEach((node, col_index) => {\n        nodes.push(<Node \n                      key={node.id} \n                      id={node.id} \n                      status={node.status} \n                      row_index={row_index}\n                      col_index={col_index}\n                      toggleObstacle={toggleObstacle}\n                      handleMouseDown={handleMouseDown}\n                      handleMouseEnter={handleMouseEnter}\n                      handleMouseUp={handleMouseUp}\n                      />)\n      });\n    });\n  }\n\n  return (\n    <div className='top-wrapper'>\n      <div>\n        <input type=\"radio\" id=\"dfs\" name=\"algo\" value=\"dfs\" checked={algorithm === 'dfs'} onChange={e => { setAlgorithm(e.target.value); setGrid(initialGrid(start, end, obstacle)); }}/>\n        <label htmlFor=\"dfs\">DFS</label> <br/>\n        <input type=\"radio\" id=\"bfs\" name=\"algo\" value=\"bfs\" checked={algorithm === 'bfs'} onChange={e => { setAlgorithm(e.target.value); setGrid(initialGrid(start, end, obstacle)); }}/>\n        <label htmlFor=\"bfs\">BFS</label> <br/>\n        <input type=\"radio\" id=\"astar\" name=\"algo\" value=\"astar\" checked={algorithm === 'astar'} onChange={e => { setAlgorithm(e.target.value); setGrid(initialGrid(start, end, obstacle)); }}/>\n        <label htmlFor=\"astar\">A*</label> \n      </div>\n\n      <div className='wrapper'>\n        <div className='controls'>\n          <div>\n            <button onClick={() => setFindPath(true)}>Find Path</button>\n            <button onClick={() => window.location.reload()}>Stop/Reset</button>\n          </div>\n          <div>\n            <button onClick={handleFixStart} disabled={fixStart}>Fix Start</button>\n            <button onClick={handleFixEnd} disabled={fixEnd}>Fix End</button>\n          </div>\n        </div>\n\n        <div className='container' style={{ gridTemplateColumns: `repeat(${num_cols}, 1fr)`}}>\n          {nodes}\n        </div>\n      </div>\n    </div>\n  )\n}","import './App.css';\nimport { Grid } from './components'\n\nfunction App() {\n  return (\n    <div className='main'>\n      <Grid/>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}